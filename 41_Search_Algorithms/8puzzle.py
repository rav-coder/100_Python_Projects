"""
This solution solves the book version of the 8 puzzle problem using iterative deepening depth first search.
0 is used to donate the empty box, and it's located on the top-left spot for reaching the goal.

References:
https://www.geeksforgeeks.org/iterative-deepening-searchids-iterative-deepening-depth-first-searchiddfs/

Page 98, 3.4.4 Depth-limited and iterative deepening search,
Chapter 3 Solving Problems by Searching,
S. Russell and P. Norvig, "Artificial Intelligence: A Modern Approach," 4th ed.,
Global Edition, Upper Saddle River, NJ, USA: Pearson, 2020

"""
import copy


class Puzzle8State:
    def __init__(self, state):
        self.state = state

    # Equality comparison for the state attribute of the puzzle
    def __eq__(self, other):
        return self.state == other.state

    # Find the position of the empty box denoted by 0
    def get_empty_box(self):
        for i in range(3):
            for j in range(3):
                if self.state[i][j] == 0:
                    return i, j

    def get_all_possible_moves(self):
        i, j = self.get_empty_box()  # store the position of empty box

        # empty box can go one of left, right, up or down
        moves_available_for_empty_box = [(-1, 0), (0, 1), (1, 0), (0, -1)]

        # all possible neighbouring states that can be generated by moving the blank box in all valid directions
        current_possibilities = []

        for move in moves_available_for_empty_box:  # check moves in all directions
            ci, cj = move
            ni, nj = i + ci, j + cj  # apply one of the four moves and store the new position

            if (0 <= ni < 3) and (0 <= nj < 3):   # if the move is valid i.e. within the box
                possible_state = copy.deepcopy(self.state)  # deep copy for the state
                possible_state[i][j], possible_state[ni][nj] \
                    = possible_state[ni][nj], possible_state[i][j]  # swap the empty box with a numbered box
                current_possibilities.append(Puzzle8State(possible_state))

        return current_possibilities


def depth_limited_dfs(state, goal_state, depth_limit):
    if state == goal_state:
        return True

    if depth_limit == 0:
        return False

    # recursive call until a goal state is found
    for possibility in state.get_all_possible_moves():
        if depth_limited_dfs(possibility, goal_state, depth_limit - 1):
            return True

    return False


def i_deepening_dfs(in_state, goal_state):
    depth_limit = 0

    # incrementally increase the depth as long as the goal state is not reached
    while True:
        if depth_limited_dfs(in_state, goal_state, depth_limit):
            return depth_limit

        depth_limit += 1


# Values for the input and goal state for the board
input_state = Puzzle8State([[1, 4, 2], [3, 7, 5], [6, 8, 0]])
goal_state = Puzzle8State([[0, 1, 2], [3, 4, 5], [6, 7, 8]])

# Assign and print the total moves needed
num_moves = i_deepening_dfs(input_state, goal_state)
print(f'Number of moved needed to transform input to goal state: {num_moves}')



